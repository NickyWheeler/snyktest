// src/errors.ts
var ERROR_CODES = {
  INPUT_PARSE_ERROR: "INPUT_PARSE_ERROR",
  OUTPUT_PARSE_ERROR: "OUTPUT_PARSE_ERROR",
  ERROR: "ERROR",
  NOT_AUTHORIZED: "NOT_AUTHORIZED",
  TIMEOUT: "TIMEOUT",
  INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR",
  FORBIDDEN: "FORBIDDEN",
  NOT_FOUND: "NOT_FOUND",
  CONFLICT: "CONFLICT",
  PRECONDITION_FAILED: "PRECONDITION_FAILED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  METHOD_NOT_SUPPORTED: "METHOD_NOT_SUPPORTED",
  UNPROCESSABLE_CONTENT: "UNPROCESSABLE_CONTENT",
  TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS",
  CLIENT_CLOSED_REQUEST: "CLIENT_CLOSED_REQUEST"
};
var ZSAError = class extends Error {
  /** the Error object thrown */
  data;
  /** the error code */
  code;
  constructor(code = ERROR_CODES.ERROR, data) {
    super();
    this.data = data;
    this.code = code;
    if (data instanceof Error) {
      this.message = data.message;
      this.stack = data.stack;
      this.name = data.name;
      this.cause = data.cause;
    }
    if (!this.message && typeof this.data === "string") {
      this.message = this.data;
    }
  }
};

// src/procedure.ts
import z3 from "zod";

// src/utils.ts
import { z } from "zod";
var instanceofZodTypeKind = (type, zodTypeKind) => {
  return type?._def?.typeName === zodTypeKind;
};
var unwrapZodType = (type, unwrapPreprocess) => {
  if (instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodOptional)) {
    return unwrapZodType(type.unwrap(), unwrapPreprocess);
  }
  if (instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodDefault)) {
    return unwrapZodType(type.removeDefault(), unwrapPreprocess);
  }
  if (instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodLazy)) {
    return unwrapZodType(type._def.getter(), unwrapPreprocess);
  }
  if (instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodEffects)) {
    if (type._def.effect.type === "refinement") {
      return unwrapZodType(type._def.schema, unwrapPreprocess);
    }
    if (type._def.effect.type === "transform") {
      return unwrapZodType(type._def.schema, unwrapPreprocess);
    }
    if (unwrapPreprocess && type._def.effect.type === "preprocess") {
      return unwrapZodType(type._def.schema, unwrapPreprocess);
    }
  }
  return type;
};
var instanceofZodTypeObject = (type) => {
  return instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodObject);
};
var instanceofZodTypeArray = (type) => {
  return instanceofZodTypeKind(type, z.ZodFirstPartyTypeKind.ZodArray);
};
var isKeyAnArrayInZodSchema = (key, schema) => {
  const unwrapped = unwrapZodType(schema, true);
  const isObject = instanceofZodTypeObject(unwrapped);
  if (!isObject)
    return false;
  const shape = unwrapped.shape;
  if (!(key in shape))
    return false;
  const value = shape[key];
  if (!value)
    return false;
  const unwrappedValue = unwrapZodType(value, true);
  const isArray = instanceofZodTypeArray(unwrappedValue);
  return isArray;
};
var formDataToJson = (formData, inputSchema) => {
  const json = {};
  formData.forEach((value, key) => {
    const isArraySchema = isKeyAnArrayInZodSchema(key, inputSchema);
    if (!Reflect.has(json, key)) {
      json[key] = isArraySchema ? [value] : value;
      return;
    }
    if (!Array.isArray(json[key])) {
      json[key] = [json[key]];
    }
    json[key].push(value);
  });
  return json;
};
var addToNullishArray = (array, value) => {
  if (!array && !value)
    return void 0;
  if (!value)
    return array;
  const temp = [...array || []];
  temp.push(value);
  return temp;
};
var mergeArraysAndRemoveDuplicates = (array1, array2) => {
  if (!array1 && !array2)
    return void 0;
  if (!array2)
    return array1;
  if (!array1)
    return array2;
  const temp = [...array1 || [], ...array2 || []];
  return [...new Set(temp)];
};

// src/zod-safe-function.ts
import { z as z2 } from "zod";
var ZodSafeFunction = class _ZodSafeFunction {
  /** The internals of the Zod Safe Function */
  $internals;
  constructor(internals) {
    this.$internals = internals;
  }
  /** Check if the timeout has triggered, if so, throw a ZSAError */
  checkTimeoutStatus(timeoutStatus) {
    if (timeoutStatus.isTimeout) {
      throw new ZSAError(
        "TIMEOUT",
        `Exceeded timeout of ${this.$internals.timeout} ms`
      );
    }
  }
  /**
   *
   * Get the retry delay for the current retry attempt
   *
   * If there should be no retry, returns -1
   */
  getRetryDelay($err, currentAttempt) {
    try {
      const err = $err instanceof ZSAError ? $err : new ZSAError("ERROR", $err);
      if (err.code === "TIMEOUT") {
        return -1;
      }
      const config = this.$internals.retryConfig;
      if (!config)
        return -1;
      if (this.$internals.isProcedure)
        return -1;
      const shouldRetry = currentAttempt < config.maxAttempts;
      let retryDelay = 0;
      if (typeof config.delay === "function") {
        retryDelay = config.delay(currentAttempt, err);
      } else if (typeof config.delay === "number") {
        retryDelay = config.delay;
      }
      if (shouldRetry)
        return retryDelay;
      return -1;
    } catch {
      return -1;
    }
  }
  /**
   *  Run through the procedure chain and get the final context
   */
  async getProcedureChainOutput(args, timeoutStatus, request, responseMeta, previousState) {
    let accData = void 0;
    for (let i = 0; i < this.$internals.procedureHandlerChain.length; i += 1) {
      this.checkTimeoutStatus(timeoutStatus);
      const procedureHandler = this.$internals.procedureHandlerChain[i];
      const [data, err] = await procedureHandler(args, void 0, {
        ctx: accData,
        request,
        responseMeta,
        previousState
      });
      if (err) {
        throw err;
      }
      accData = data;
    }
    return accData;
  }
  /** set a timeout on the server action */
  timeout(milliseconds) {
    return new _ZodSafeFunction({
      ...this.$internals,
      timeout: milliseconds
    });
  }
  /** set a retry mechanism on the server action */
  retry(config) {
    return new _ZodSafeFunction({
      ...this.$internals,
      retryConfig: config
    });
  }
  /**
   * set the input schema for the server action
   *
   * @example
   * ```ts
   * .input(z.object({
   *   message: z.string()
   * }))
   * ```
   */
  input(schema, opts) {
    return new _ZodSafeFunction({
      ...this.$internals,
      // @ts-expect-error
      inputSchema: this.$internals.inputSchema instanceof z2.ZodUndefined ? schema : schema.and(this.$internals.inputSchema),
      inputType: opts?.type
    });
  }
  /** set the output schema for the server action */
  output(schema) {
    return new _ZodSafeFunction({
      ...this.$internals,
      // @ts-expect-error
      outputSchema: schema
    });
  }
  /** set a handler function for input parse errors */
  onInputParseError(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onInputParseError: fn
    });
  }
  /** set a handler function for output parse errors */
  onOutputParseError(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onOutputParseError: fn
    });
  }
  /** set a handler function for errors */
  onError(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onErrorFn: fn
    });
  }
  /** set a handler function for when the server action starts */
  onStart(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onStartFn: fn
    });
  }
  /** set a handler function for when the server action succeeds */
  onSuccess(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onSuccessFn: fn
    });
  }
  /** set a handler function for when the server action completes (success or error) */
  onComplete(fn) {
    return new _ZodSafeFunction({
      ...this.$internals,
      onCompleteFn: fn
    });
  }
  /** a helper function to parse output data given the active output schema */
  async parseOutputData(data, timeoutStatus) {
    this.checkTimeoutStatus(timeoutStatus);
    if (!this.$internals.outputSchema || this.$internals.outputSchema instanceof z2.ZodUndefined)
      return data;
    const safe = await this.$internals.outputSchema.safeParseAsync(data);
    if (!safe.success) {
      if (this.$internals.onOutputParseError) {
        await this.$internals.onOutputParseError(safe.error);
      }
      safe.error.flatten();
      throw new ZSAError("OUTPUT_PARSE_ERROR", safe.error);
    }
    return safe.data;
  }
  /** helper function to handle start with timeout checkpoints */
  async handleStart(args, timeoutStatus) {
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onStartFromProcedureFn && !this.$internals.isProcedure) {
      for (const fn of this.$internals.onStartFromProcedureFn) {
        await fn({ args });
      }
    }
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onStartFn && !this.$internals.isProcedure) {
      await this.$internals.onStartFn({
        args
      });
    }
  }
  /** helper function to handle success with timeout checkpoints */
  async handleSuccess(args, data, timeoutStatus) {
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onSuccessFromProcedureFn && !this.$internals.isProcedure) {
      for (const fn of this.$internals.onSuccessFromProcedureFn) {
        await fn({ args, data });
      }
    }
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onSuccessFn && !this.$internals.isProcedure) {
      await this.$internals.onSuccessFn({
        args,
        data
      });
    }
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onCompleteFromProcedureFn && !this.$internals.isProcedure) {
      for (const fn of this.$internals.onCompleteFromProcedureFn) {
        await fn({
          isSuccess: true,
          isError: false,
          status: "success",
          args,
          data
        });
      }
    }
    this.checkTimeoutStatus(timeoutStatus);
    if (this.$internals.onCompleteFn && !this.$internals.isProcedure) {
      await this.$internals.onCompleteFn({
        isSuccess: true,
        isError: false,
        status: "success",
        args,
        data
      });
    }
  }
  /** helper function to handle errors with timeout checkpoints */
  async handleError(err) {
    if (err.message === "NEXT_REDIRECT" || err.message === "NEXT_NOT_FOUND") {
      throw err;
    }
    const customError = err instanceof ZSAError ? err : new ZSAError("ERROR", err);
    if (this.$internals.onErrorFromProcedureFn && !this.$internals.isProcedure) {
      for (const fn of this.$internals.onErrorFromProcedureFn) {
        await fn(customError);
      }
    }
    if (this.$internals.onErrorFn && !this.$internals.isProcedure) {
      await this.$internals.onErrorFn(customError);
    }
    if (this.$internals.onCompleteFromProcedureFn && !this.$internals.isProcedure) {
      for (const fn of this.$internals.onCompleteFromProcedureFn) {
        await fn({
          isSuccess: false,
          isError: true,
          status: "error",
          error: customError
        });
      }
    }
    if (this.$internals.onCompleteFn && !this.$internals.isProcedure) {
      await this.$internals.onCompleteFn({
        isSuccess: false,
        isError: true,
        status: "error",
        error: customError
      });
    }
    if (this.$internals.isProcedure) {
      return [null, customError];
    }
    const stringifyIfNeeded = (data2) => typeof data2 === "string" ? data2 : JSON.stringify(data2);
    let formattedErrors;
    let flattenedErrors;
    const data = err.data;
    if (data instanceof z2.ZodError && customError.code === "INPUT_PARSE_ERROR") {
      formattedErrors = data.format();
      flattenedErrors = data.flatten();
    }
    return [
      null,
      {
        data: stringifyIfNeeded(customError.data),
        name: customError.name,
        stack: JSON.stringify(customError.stack),
        message: stringifyIfNeeded(customError.message),
        code: customError.code,
        fieldErrors: flattenedErrors?.fieldErrors,
        formErrors: flattenedErrors?.formErrors,
        formattedErrors
      }
    ];
  }
  /** helper function to parse input data given the active input schema */
  async parseInputData(data, timeoutStatus, $overrideInputSchema) {
    this.checkTimeoutStatus(timeoutStatus);
    const inputSchema = $overrideInputSchema || this.$internals.inputSchema;
    if (!inputSchema)
      return data;
    if (inputSchema instanceof z2.ZodUndefined)
      return void 0;
    const safe = await inputSchema.safeParseAsync(data);
    if (!safe.success) {
      if (this.$internals.onInputParseError) {
        await this.$internals.onInputParseError(safe.error);
      }
      throw new ZSAError("INPUT_PARSE_ERROR", safe.error);
    }
    return safe.data;
  }
  getTimeoutErrorPromise = (timeoutMs) => new Promise((_, reject) => {
    setTimeout(() => {
      reject(new ZSAError("TIMEOUT", `Exceeded timeout of ${timeoutMs} ms`));
    }, timeoutMs);
  });
  /** set the handler function for the server action */
  handler(fn) {
    const timeoutStatus = {
      isTimeout: false
    };
    const wrapper = async ($args, overrideArgs, opts) => {
      if (opts?.returnInputSchema) {
        return this.$internals.inputSchema;
      } else if (opts?.returnOutputSchema) {
        return this.$internals.outputSchema;
      }
      let args;
      if (this.$internals.inputType === "state") {
        args = overrideArgs;
      } else {
        args = $args;
      }
      let previousState = opts?.previousState || void 0;
      if (this.$internals.inputType === "state" && !this.$internals.isProcedure) {
        previousState = $args;
      }
      try {
        if (args instanceof FormData) {
          args = {
            ...formDataToJson(args, this.$internals.inputSchema),
            ...this.$internals.inputType !== "state" ? overrideArgs || {} : {}
          };
        }
        await this.handleStart(args, timeoutStatus);
        if (!this.$internals.inputSchema && !this.$internals.isChained)
          throw new Error("No input schema");
        const ctx = this.$internals.isProcedure && opts ? opts.ctx : await this.getProcedureChainOutput(
          args,
          timeoutStatus,
          opts?.request,
          opts?.responseMeta,
          previousState
        );
        const input = await this.parseInputData(
          args,
          timeoutStatus,
          opts?.overrideInputSchema
        );
        this.checkTimeoutStatus(timeoutStatus);
        const data = await fn({
          input,
          ctx,
          request: opts?.request,
          responseMeta: opts?.responseMeta,
          previousState
        });
        const parsed = await this.parseOutputData(data, timeoutStatus);
        await this.handleSuccess(input, parsed, timeoutStatus);
        return [parsed, null];
      } catch (err) {
        const retryDelay = this.getRetryDelay(err, opts?.attempts || 1);
        if (retryDelay >= 0) {
          await new Promise((r) => setTimeout(r, retryDelay));
          return await wrapper($args, overrideArgs, {
            ...opts || {},
            attempts: (opts?.attempts || 1) + 1
          });
        }
        return await this.handleError(err);
      }
    };
    const withTimeout = async (args, overrideArgs, opts) => {
      const timeoutMs = this.$internals.timeout;
      if (!timeoutMs)
        return await wrapper(args, overrideArgs, opts);
      return await Promise.race([
        wrapper(args, overrideArgs, opts),
        this.getTimeoutErrorPromise(timeoutMs)
      ]).then((r) => r).catch((err) => {
        timeoutStatus.isTimeout = true;
        return this.handleError(err);
      });
    };
    if (this.$internals.isProcedure) {
      const handler = this.$internals.timeout ? withTimeout : wrapper;
      return new CompleteProcedure({
        inputSchema: this.$internals.inputSchema,
        handlerChain: [...this.$internals.procedureHandlerChain, handler],
        lastHandler: handler,
        onCompleteFns: addToNullishArray(
          this.$internals.onCompleteFromProcedureFn,
          this.$internals.onCompleteFn
        ),
        onErrorFns: addToNullishArray(
          this.$internals.onErrorFromProcedureFn,
          this.$internals.onErrorFn
        ),
        onStartFns: addToNullishArray(
          this.$internals.onStartFromProcedureFn,
          this.$internals.onStartFn
        ),
        onSuccessFns: addToNullishArray(
          this.$internals.onSuccessFromProcedureFn,
          this.$internals.onSuccessFn
        ),
        timeout: this.$internals.timeout,
        retryConfig: this.$internals.retryConfig
      });
    }
    if (this.$internals.timeout) {
      return withTimeout;
    }
    return wrapper;
  }
};
function createZodSafeFunction(isProcedure, parentProcedure) {
  return new ZodSafeFunction({
    inputSchema: parentProcedure?.$internals.inputSchema || z2.undefined(),
    outputSchema: z2.undefined(),
    isChained: parentProcedure !== void 0,
    isProcedure: isProcedure === true,
    procedureHandlerChain: parentProcedure?.$internals.handlerChain || [],
    onCompleteFromProcedureFn: parentProcedure?.$internals.onCompleteFns,
    onErrorFromProcedureFn: parentProcedure?.$internals.onErrorFns,
    onStartFromProcedureFn: parentProcedure?.$internals.onStartFns,
    onSuccessFromProcedureFn: parentProcedure?.$internals.onSuccessFns
  });
}
function createServerAction() {
  return new ZodSafeFunction({
    inputSchema: z2.undefined(),
    outputSchema: z2.undefined(),
    procedureHandlerChain: []
  });
}

// src/procedure.ts
var CompleteProcedure = class {
  $internals;
  constructor(params) {
    this.$internals = params;
  }
  /** make a server action with the current procedure */
  createServerAction() {
    return new ZodSafeFunction({
      inputSchema: this.$internals.inputSchema,
      outputSchema: z3.undefined(),
      procedureHandlerChain: this.$internals.handlerChain,
      onErrorFromProcedureFn: this.$internals.onErrorFns,
      onStartFromProcedureFn: this.$internals.onStartFns,
      onSuccessFromProcedureFn: this.$internals.onSuccessFns,
      onCompleteFromProcedureFn: this.$internals.onCompleteFns,
      timeout: this.$internals.timeout,
      retryConfig: this.$internals.retryConfig
    });
  }
};
var createServerActionProcedure = (parent) => {
  return createZodSafeFunction(true, parent);
};
var chainServerActionProcedures = (first, second) => {
  let inputSchema = first.$internals.inputSchema instanceof z3.ZodUndefined ? second.$internals.inputSchema : first.$internals.inputSchema.and(second.$internals.inputSchema);
  const newLastHandler = async (input, overrideArgs, opts) => await second.$internals.lastHandler(input, overrideArgs, {
    ...opts,
    overrideInputSchema: opts?.overrideInputSchema || inputSchema
  });
  return new CompleteProcedure({
    inputSchema,
    handlerChain: [...first.$internals.handlerChain, newLastHandler],
    lastHandler: newLastHandler,
    timeout: second.$internals.timeout || first.$internals.timeout,
    retryConfig: second.$internals.retryConfig || first.$internals.retryConfig,
    onErrorFns: mergeArraysAndRemoveDuplicates(
      first.$internals.onErrorFns,
      second.$internals.onErrorFns
    ),
    onStartFns: mergeArraysAndRemoveDuplicates(
      first.$internals.onStartFns,
      second.$internals.onStartFns
    ),
    onSuccessFns: mergeArraysAndRemoveDuplicates(
      first.$internals.onSuccessFns,
      second.$internals.onSuccessFns
    ),
    onCompleteFns: mergeArraysAndRemoveDuplicates(
      first.$internals.onCompleteFns,
      second.$internals.onCompleteFns
    )
  });
};

// src/types.ts
var DefaultOmitted = {
  $internals: 1,
  handleError: 1,
  onInputParseError: 1,
  getTimeoutErrorPromise: 1,
  getProcedureChainOutput: 1,
  handleSuccess: 1,
  handleStart: 1,
  parseInputData: 1,
  parseOutputData: 1,
  onOutputParseError: 1,
  checkTimeoutStatus: 1,
  getRetryDelay: 1
};
var ZSAResponseMeta = class {
  /**
   * the headers of the response
   */
  headers;
  /**
   * the status code of the response
   *
   * @default 200
   */
  statusCode;
  constructor() {
    this.statusCode = 200;
    this.headers = new Headers();
  }
};
export {
  CompleteProcedure,
  DefaultOmitted,
  ZSAError,
  ZSAResponseMeta,
  ZodSafeFunction,
  addToNullishArray,
  chainServerActionProcedures,
  createServerAction,
  createServerActionProcedure,
  createZodSafeFunction,
  formDataToJson,
  instanceofZodTypeArray,
  instanceofZodTypeKind,
  instanceofZodTypeObject,
  isKeyAnArrayInZodSchema,
  mergeArraysAndRemoveDuplicates,
  unwrapZodType
};
