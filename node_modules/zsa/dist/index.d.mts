import z$1, { z } from 'zod';

/** An enum of error codes */
declare const ERROR_CODES: {
    readonly INPUT_PARSE_ERROR: "INPUT_PARSE_ERROR";
    readonly OUTPUT_PARSE_ERROR: "OUTPUT_PARSE_ERROR";
    readonly ERROR: "ERROR";
    readonly NOT_AUTHORIZED: "NOT_AUTHORIZED";
    readonly TIMEOUT: "TIMEOUT";
    readonly INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR";
    readonly FORBIDDEN: "FORBIDDEN";
    readonly NOT_FOUND: "NOT_FOUND";
    readonly CONFLICT: "CONFLICT";
    readonly PRECONDITION_FAILED: "PRECONDITION_FAILED";
    readonly PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE";
    readonly METHOD_NOT_SUPPORTED: "METHOD_NOT_SUPPORTED";
    readonly UNPROCESSABLE_CONTENT: "UNPROCESSABLE_CONTENT";
    readonly TOO_MANY_REQUESTS: "TOO_MANY_REQUESTS";
    readonly CLIENT_CLOSED_REQUEST: "CLIENT_CLOSED_REQUEST";
};
/**
 *  A ZSAError is an error that can be thrown by a server action.
 */
declare class ZSAError extends Error {
    /** the Error object thrown */
    readonly data: unknown;
    /** the error code */
    readonly code: keyof typeof ERROR_CODES;
    constructor(code?: keyof typeof ERROR_CODES, data?: unknown);
}
/**
 * A TZSAError is a ZSAError that is thrown by a server action that has a type
 */
type TZSAError<TInputSchema extends z.ZodType> = Error & ({
    code: Exclude<keyof typeof ERROR_CODES, "INPUT_PARSE_ERROR">;
    message?: string;
    stack: string;
    data: string;
    name: string;
    fieldErrors?: undefined;
    formErrors?: undefined;
    formattedErrors?: undefined;
} | {
    message?: string;
    stack: string;
    code: "INPUT_PARSE_ERROR";
    data: string;
    name: string;
    fieldErrors: z.inferFlattenedErrors<TInputSchema>["fieldErrors"];
    formErrors: z.inferFlattenedErrors<TInputSchema>["formErrors"];
    formattedErrors: z.inferFormattedError<TInputSchema>;
});

/** An error handler function */
interface TOnErrorFn {
    (err: ZSAError): any;
}
/** A start handler function */
interface TOnStartFn<TInputSchema extends z$1.ZodType, TIsProcedure extends boolean> {
    (value: {
        /** The known args passed to the handler */
        args: TIsProcedure extends false ? TInputSchema["_input"] : unknown;
    }): any;
}
/** A success handler function */
interface TOnSuccessFn<TInputSchema extends z$1.ZodType, TOutputSchema extends z$1.ZodType, TIsProcedure extends boolean> {
    (value: {
        /** The known args passed to the handler */
        args: TIsProcedure extends false ? TInputSchema["_output"] : unknown;
        /** The successful data returned from the handler */
        data: TIsProcedure extends false ? TOutputSchema["_output"] : unknown;
    }): any;
}
/**
 * A complete handler function
 *
 * Runs after onSuccess or onError
 */
interface TOnCompleteFn<TInputSchema extends z$1.ZodType, TOutputSchema extends z$1.ZodType, TIsProcedure extends boolean> {
    (value: {
        /** A boolean indicating if the action was successful */
        isSuccess: true;
        /** A boolean indicating if the action was an error */
        isError: false;
        /** The status of the action */
        status: "success";
        /** The known args passed to the handler */
        args: TIsProcedure extends false ? TInputSchema["_output"] : unknown;
        /** The successful data returned from the handler */
        data: TIsProcedure extends false ? TOutputSchema["_output"] : unknown;
    } | {
        /** A boolean indicating if the action was successful */
        isSuccess: false;
        /** A boolean indicating if the action was an error */
        isError: true;
        /** The status of the action */
        status: "error";
        /** The error thrown by the handler */
        error: ZSAError;
    }): any;
}

/**
 * An interface representing a NextRequest type
 *
 * https://nextjs.org/docs/app/api-reference/functions/next-request
 */
interface DomainLocale {
    defaultLocale: string;
    domain: string;
    http?: true;
    locales?: string[];
}
interface NextURL {
    buildId?: string | undefined;
    locale: string;
    defaultLocale?: string | undefined;
    domainLocale?: DomainLocale | undefined;
    searchParams: URLSearchParams;
    host: string;
    hostname: string;
    port: string;
    protocol: string;
    href: string;
    origin: string;
    pathname: string;
    hash: string;
    search: string;
    password: string;
    username: string;
    basePath: string;
}
type RequestCookie = {
    name: string;
    value: string;
};
interface RequestCookies {
    size: number;
    get(...args: [name: string] | [RequestCookie]): RequestCookie | undefined;
    getAll(...args: [name: string] | [RequestCookie] | []): RequestCookie[];
    has(name: string): boolean;
    set(...args: [key: string, value: string] | [options: RequestCookie]): this;
    delete(names: string | string[]): boolean | boolean[];
    clear(): this;
    toString(): string;
}
interface NextRequest extends Request {
    geo: {
        city?: string | undefined;
        country?: string | undefined;
        region?: string | undefined;
        latitude?: string | undefined;
        longitude?: string | undefined;
    } | undefined;
    ip: string | undefined;
    nextUrl: NextURL;
    url: string;
    cookies: RequestCookies;
}

/** Replace void with undefined */
type TCleanData<T extends Promise<any>> = Extract<Awaited<T>, void> extends never ? Awaited<T> : Exclude<Awaited<T>, void> | undefined;
/** The return type of a server action */
type TDataOrError<TInputSchema extends z.ZodType, TData extends Promise<any>> = Promise<[TCleanData<TData>, null]> | Promise<[null, TZSAError<TInputSchema>]>;
/** The return type of a server action */
type TDataOrErrorOrNull<TInputSchema extends z.ZodType, TData extends Promise<any>> = [TCleanData<TData>, null] | [null, TZSAError<TInputSchema>] | [null, null];
/** A configuration object for retrying a server action */
interface RetryConfig {
    /** The maximum number of times to retry the action. Inclusive. */
    maxAttempts: number;
    /**
     * The delay in milliseconds between each retry attempt.
     *
     * Can either be a number (ms) or a function that takes the
     * current attempt number and the error as arguments and returns a number of ms.
     *
     * NOTE: The current attempt starts at 2
     * (the first attempt errored then the current attempt becomes is 2)
     *
     * @example
     * Exponential backoff
     * ```ts
     * delay: (currentAttempt) =>
     *   Math.min(
     *     currentAttempt > 2 ? 2 ** currentAttempt * 1000 : 1000,
     *     30 * 1000
     *   ),
     * ```
     *
     * @example
     * Linear backoff
     * ```ts
     * delay: (currentAttempt) =>
     *   (currentAttempt - 1) * 1000,
     * ```
     */
    delay?: number | ((currentAttempt: number, err: ZSAError) => number);
}
interface THandlerOpts<TProcedureChainOutput extends any> {
    /** The context of the handler */
    ctx?: TProcedureChainOutput;
    /** Override the input schema */
    overrideInputSchema?: z.ZodType;
    /** return the input schema */
    returnInputSchema?: boolean;
    /** return the output schema */
    returnOutputSchema?: boolean;
    /** an associated request object from OpenAPI handlers */
    request?: NextRequest;
    /** an object containing response metadata for OpenAPI handlers */
    responseMeta?: ZSAResponseMeta;
    /** the number of attempts the handler has made */
    attempts?: number;
    /** the previous state */
    previousState?: any;
}
/** A function type for a handler that does not have an input */
interface TNoInputHandlerFunc<TRet extends any, TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TProcedureChainOutput extends any> {
    (placeholder?: undefined, $overrideArgs?: undefined, $opts?: THandlerOpts<TProcedureChainOutput>): TDataOrError<TInputSchema, TOutputSchema extends z.ZodUndefined ? TRet : TOutputSchema["_output"]>;
}
/** A function type for a handler that has an input */
interface THandlerFunc<TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TRet extends any, TProcedureChainOutput extends any, TInputType extends InputTypeOptions> {
    (
    /** The input to the handler */
    args: TInputType extends "json" ? TInputSchema["_input"] : FormData, 
    /** Override the args */
    $overrideArgs?: Partial<TInputSchema["_input"]>, 
    /** Options for the handler */
    $opts?: THandlerOpts<TProcedureChainOutput>): TDataOrError<TInputSchema, TOutputSchema extends z.ZodUndefined ? TRet : TOutputSchema["_output"]>;
}
/** A function type for a handler that has an input */
interface TStateHandlerFunc<TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TRet extends any> {
    (
    /** The previous state */
    previousState: any, 
    /** Override the args */
    formData: FormData): TDataOrErrorOrNull<TInputSchema, TOutputSchema extends z.ZodUndefined ? TRet : TOutputSchema["_output"]>;
}
type TAnyStateHandlerFunc = TStateHandlerFunc<z.ZodType, z.ZodType, any>;
/** a helper type to hold the status of a timeout */
interface TimeoutStatus {
    isTimeout: boolean;
}
/** which keys should be default omitted from the safe zod function */
declare const DefaultOmitted: {
    readonly $internals: 1;
    readonly handleError: 1;
    readonly onInputParseError: 1;
    readonly getTimeoutErrorPromise: 1;
    readonly getProcedureChainOutput: 1;
    readonly handleSuccess: 1;
    readonly handleStart: 1;
    readonly parseInputData: 1;
    readonly parseOutputData: 1;
    readonly onOutputParseError: 1;
    readonly checkTimeoutStatus: 1;
    readonly getRetryDelay: 1;
};
type TZodSafeFunctionDefaultOmitted = keyof typeof DefaultOmitted;
/** A combination of both a no input handler and a handler */
type TAnyZodSafeFunctionHandler<TInputSchema extends z.ZodType = z.ZodType, TData extends Promise<any> = Promise<any>> = ((input: any, overrideArgs?: any, opts?: THandlerOpts<any>) => TDataOrError<TInputSchema, TData>) | ((placeholder?: undefined, overrideArgs?: undefined, opts?: THandlerOpts<any>) => TDataOrError<TInputSchema, TData>);
/** infer input schema */
type inferInputSchemaFromHandler<THandler extends TAnyZodSafeFunctionHandler> = THandler extends TAnyZodSafeFunctionHandler<infer TInputSchema> ? TInputSchema : THandler extends TStateHandlerFunc<infer TInputSchema, any, any> ? TInputSchema : z.ZodType;
/**
 * A data type for the internals of a Zod Safe Function
 */
interface TInternals<TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TIsProcedure extends boolean> {
    /**
     *
     * A chain of handler functions to run before the main handler (if any)
     *
     * These would come from the procedure chain
     *
     */
    procedureHandlerChain: TAnyZodSafeFunctionHandler[];
    /** The final input schema of the handler */
    inputSchema: TInputSchema;
    /** The final output schema of the handler */
    outputSchema: TOutputSchema;
    /** A function to run when an input parse error occurs */
    onInputParseError?: ((err: z.ZodError<TInputSchema>) => any) | undefined;
    /** A function to run when the output parse error occurs */
    onOutputParseError?: ((err: z.ZodError<TOutputSchema>) => any) | undefined;
    /**
     * The timeout of the handler in milliseconds
     */
    timeout?: number | undefined;
    /**
     * The retry configuration of the handler
     */
    retryConfig?: RetryConfig | undefined;
    /** A function to run when the handler errors */
    onErrorFn?: TOnErrorFn | undefined;
    /** the type of input */
    inputType?: InputTypeOptions;
    /** A function to run when the handler starts */
    onStartFn?: TOnStartFn<TInputSchema, TIsProcedure> | undefined;
    /** A function to run when the handler succeeds */
    onSuccessFn?: TOnSuccessFn<TInputSchema, TOutputSchema, TIsProcedure> | undefined;
    /** A function to run when the handler completes (success or error) */
    onCompleteFn?: TOnCompleteFn<TInputSchema, TOutputSchema, TIsProcedure> | undefined;
    /** The procedure function to run when an error occurs */
    onErrorFromProcedureFn?: Array<TOnErrorFn> | undefined;
    /** The procedure function to run when the handler starts */
    onStartFromProcedureFn?: Array<TOnStartFn<TInputSchema, true>> | undefined;
    /** The procedure function to run when the handler succeeds */
    onSuccessFromProcedureFn?: Array<TOnSuccessFn<TInputSchema, TOutputSchema, true>> | undefined;
    /** The procedure function to run when the handler completes (success or error) */
    onCompleteFromProcedureFn?: Array<TOnCompleteFn<TInputSchema, TOutputSchema, true>> | undefined;
    /** Boolean indicating if the procedure has a parent */
    isChained?: boolean | undefined;
    /** Boolean indicating if the handler is a procedure */
    isProcedure?: TIsProcedure | undefined;
    /** The handler function */
    handler?: TAnyZodSafeFunctionHandler | undefined;
}
type InputTypeOptions = "formData" | "json" | "state";
/**
 * A class representing a ZSA response meta object
 */
declare class ZSAResponseMeta {
    /**
     * the headers of the response
     */
    headers: Headers;
    /**
     * the status code of the response
     *
     * @default 200
     */
    statusCode: number;
    constructor();
}
type PrettifyNested<T> = T extends Record<string, any> ? {
    [K in keyof T]: PrettifyNested<T[K]>;
} : T;

/** A helper type to hold any zod safe function */
interface TAnyZodSafeFunction extends ZodSafeFunction<any, any, any, any, boolean, any> {
}
/** A helper type to wrap ZodSafeFunction in an Omit */
type TZodSafeFunction<TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TOmitted extends string, TProcedureChainOutput extends any, TIsProcedure extends boolean, TInputType extends InputTypeOptions> = Omit<ZodSafeFunction<TInputSchema, TOutputSchema, TOmitted, TProcedureChainOutput, TIsProcedure, TInputType>, TOmitted>;
declare class ZodSafeFunction<TInputSchema extends z.ZodType, TOutputSchema extends z.ZodType, TOmitted extends string, TProcedureChainOutput extends any, TIsProcedure extends boolean, TInputType extends InputTypeOptions> {
    /** The internals of the Zod Safe Function */
    $internals: TInternals<TInputSchema, TOutputSchema, TIsProcedure>;
    constructor(internals: TInternals<TInputSchema, TOutputSchema, TIsProcedure>);
    /** Check if the timeout has triggered, if so, throw a ZSAError */
    checkTimeoutStatus(timeoutStatus: TimeoutStatus): void;
    /**
     *
     * Get the retry delay for the current retry attempt
     *
     * If there should be no retry, returns -1
     */
    getRetryDelay($err: unknown, currentAttempt: number): number;
    /**
     *  Run through the procedure chain and get the final context
     */
    getProcedureChainOutput(args: TInputSchema["_input"], timeoutStatus: TimeoutStatus, request: NextRequest | undefined, responseMeta: ZSAResponseMeta | undefined, previousState?: any): Promise<TProcedureChainOutput>;
    /** set a timeout on the server action */
    timeout<T extends number>(milliseconds: T): TZodSafeFunction<TInputSchema, TOutputSchema, TOmitted | "timeout", TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a retry mechanism on the server action */
    retry(config: RetryConfig): TZodSafeFunction<TInputSchema, TOutputSchema, TOmitted | "retry", TProcedureChainOutput, TIsProcedure, TInputType>;
    /**
     * set the input schema for the server action
     *
     * @example
     * ```ts
     * .input(z.object({
     *   message: z.string()
     * }))
     * ```
     */
    input<T extends z.ZodType, TType extends TIsProcedure extends false ? InputTypeOptions : "json" = "json">(schema: T, opts?: {
        type?: TType;
    }): TZodSafeFunction<TInputSchema extends z.ZodUndefined ? T : z.ZodIntersection<TInputSchema, T>, TOutputSchema, "input" | Exclude<TOmitted, "onInputParseError">, // bring back the onInputParseError
    TProcedureChainOutput, TIsProcedure, TType>;
    /** set the output schema for the server action */
    output<T extends z.ZodType>(schema: T): TZodSafeFunction<TInputSchema, T, "output" | Exclude<TOmitted, "onOutputParseError">, TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for input parse errors */
    onInputParseError(fn: (err: z.ZodError<TIsProcedure extends false ? TInputSchema : any>) => any): TZodSafeFunction<TInputSchema, TOutputSchema, "onInputParseError" | TOmitted, TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for output parse errors */
    onOutputParseError(fn: (err: z.ZodError<TIsProcedure extends false ? TOutputSchema : any>) => any): TZodSafeFunction<TInputSchema, TOutputSchema, "onOutputParseError" | TOmitted, TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for errors */
    onError(fn: (err: ZSAError) => any): TZodSafeFunction<TInputSchema, TOutputSchema, "onError" | TOmitted, TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for when the server action starts */
    onStart(fn: TOnStartFn<TInputSchema, TIsProcedure>): TZodSafeFunction<TInputSchema, TOutputSchema, TOmitted | "onStart", TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for when the server action succeeds */
    onSuccess(fn: TOnSuccessFn<TInputSchema, TOutputSchema, TIsProcedure>): TZodSafeFunction<TInputSchema, TOutputSchema, TOmitted | "onSuccess", TProcedureChainOutput, TIsProcedure, TInputType>;
    /** set a handler function for when the server action completes (success or error) */
    onComplete(fn: TOnCompleteFn<TInputSchema, TOutputSchema, TIsProcedure>): TZodSafeFunction<TInputSchema, TOutputSchema, TOmitted | "onComplete", TProcedureChainOutput, TIsProcedure, TInputType>;
    /** a helper function to parse output data given the active output schema */
    parseOutputData(data: any, timeoutStatus: TimeoutStatus): Promise<TOutputSchema["_output"]>;
    /** helper function to handle start with timeout checkpoints */
    handleStart(args: any, timeoutStatus: TimeoutStatus): Promise<void>;
    /** helper function to handle success with timeout checkpoints */
    handleSuccess(args: any, data: any, timeoutStatus: TimeoutStatus): Promise<void>;
    /** helper function to handle errors with timeout checkpoints */
    handleError(err: any): Promise<[null, TZSAError<TInputSchema>]>;
    /** helper function to parse input data given the active input schema */
    parseInputData(data: any, timeoutStatus: TimeoutStatus, $overrideInputSchema?: z.ZodType): Promise<TInputSchema["_output"]>;
    getTimeoutErrorPromise: (timeoutMs: number) => Promise<unknown>;
    /** set the handler function for the server action */
    handler<TRet extends TOutputSchema extends z.ZodUndefined ? any | Promise<any> : TOutputSchema["_output"] | Promise<TOutputSchema["_output"]>>(fn: (v: {
        /** the parsed input to the action */
        input: TInputSchema["_output"];
        /** the final context of the action */
        ctx: TProcedureChainOutput;
        /** a request object if the action is run from an Open API route `createOpenApiServerActionRouter` */
        request?: NextRequest;
        /** an object containing response metadata for OpenAPI handlers */
        responseMeta?: ZSAResponseMeta;
        /** the previous state when inputType is "state" */
        previousState: any;
    }) => TRet): TIsProcedure extends false ? TInputType extends "state" ? TStateHandlerFunc<TInputSchema, TOutputSchema, TRet> : TInputSchema extends z.ZodUndefined ? TNoInputHandlerFunc<TRet, TInputSchema, TOutputSchema, TProcedureChainOutput> : THandlerFunc<TInputSchema, TOutputSchema, TRet, TProcedureChainOutput, TInputType> : CompleteProcedure<TInputSchema, THandlerFunc<TInputSchema, TOutputSchema, TRet, TProcedureChainOutput, "json">>;
}
declare function createZodSafeFunction<TIsProcedure extends boolean>(isProcedure?: TIsProcedure, parentProcedure?: TAnyCompleteProcedure): TZodSafeFunction<z.ZodUndefined, z.ZodUndefined, TZodSafeFunctionDefaultOmitted, undefined, TIsProcedure, "json">;
type inferServerActionReturnData<TAction extends TAnyZodSafeFunctionHandler> = NonNullable<Awaited<ReturnType<TAction>>[0]> extends never ? undefined : NonNullable<Awaited<ReturnType<TAction>>[0]>;
type inferServerActionError<TAction extends TAnyZodSafeFunctionHandler> = NonNullable<Awaited<ReturnType<TAction>>[1]>;
type inferServerActionReturnType<TAction extends TAnyZodSafeFunctionHandler> = Awaited<ReturnType<TAction>>;
type inferServerActionReturnTypeHot<TAction extends TAnyZodSafeFunctionHandler> = ReturnType<TAction>;
type inferServerActionInput<TAction extends TAnyZodSafeFunctionHandler> = Parameters<TAction>[0];
declare function createServerAction(): TZodSafeFunction<z.ZodUndefined, z.ZodUndefined, TZodSafeFunctionDefaultOmitted, undefined, false, "json">;

/** Internal data stored inside a server action procedure */
interface TCompleteProcedureInternals<TInputSchema extends z$1.ZodType, THandler extends TAnyZodSafeFunctionHandler> {
    /** The chained input schema */
    inputSchema: TInputSchema;
    /** An ordered array of handlers */
    handlerChain: TAnyZodSafeFunctionHandler[];
    /** The last handler in the chain */
    lastHandler: THandler;
    /** A chain of error handlers */
    onErrorFns: Array<TOnErrorFn> | undefined;
    /** A chain of start handlers */
    onStartFns: Array<TOnStartFn<any, true>> | undefined;
    /** A chain of success handlers */
    onSuccessFns: Array<TOnSuccessFn<any, any, true>> | undefined;
    /** A chain of complete handlers */
    onCompleteFns: Array<TOnCompleteFn<any, any, true>> | undefined;
    /** The timeout of the procedure */
    timeout: number | undefined;
    /** The retry config of the procedure */
    retryConfig: RetryConfig | undefined;
}
/** A completed procedure */
declare class CompleteProcedure<TInputSchema extends z$1.ZodType, THandler extends TAnyZodSafeFunctionHandler> {
    $internals: TCompleteProcedureInternals<TInputSchema, THandler>;
    constructor(params: TCompleteProcedureInternals<TInputSchema, THandler>);
    /** make a server action with the current procedure */
    createServerAction(): TZodSafeFunction<TInputSchema, z$1.ZodUndefined, TInputSchema extends z$1.ZodUndefined ? TZodSafeFunctionDefaultOmitted : Exclude<TZodSafeFunctionDefaultOmitted, "input" | "onInputParseError">, inferServerActionReturnData<THandler>, false, "json">;
}
/** a helper type to hold any complete procedure */
interface TAnyCompleteProcedure extends CompleteProcedure<any, any> {
}
/** The return type of `createServerActionProcedure` given a parent procedure */
type TRet<T extends TAnyCompleteProcedure | undefined> = T extends TAnyCompleteProcedure ? TZodSafeFunction<T["$internals"]["inputSchema"], z$1.ZodUndefined, TZodSafeFunctionDefaultOmitted, inferServerActionReturnData<T["$internals"]["lastHandler"]> extends infer TData ? TData extends void ? undefined : TData : never, true, "json"> : TZodSafeFunction<z$1.ZodUndefined, z$1.ZodUndefined, TZodSafeFunctionDefaultOmitted, undefined, true, "json">;
/**
 * Create a server action procedure
 *
 * @param parent optional parent procedure to chain off of
 */
declare const createServerActionProcedure: <T extends TAnyCompleteProcedure | undefined = undefined>(parent?: T) => TRet<T>;
/**
 * Chain a server action procedure off of another
 *
 * NOTE: the context of the second procedure must extend the context of the first
 *
 * @param first the first procedure to chain off of
 * @param second the second procedure to chain off of
 */
declare const chainServerActionProcedures: <T2 extends TAnyCompleteProcedure, TOpts extends Parameters<T2["$internals"]["lastHandler"]>[2], TContext extends TOpts extends {
    ctx?: any;
} ? NonNullable<TOpts["ctx"]> : undefined, T1 extends CompleteProcedure<any, TAnyZodSafeFunctionHandler<any, TContext>>>(first: T1, second: T2) => CompleteProcedure<T1["$internals"]["inputSchema"] extends z$1.ZodUndefined ? T2["$internals"]["inputSchema"] : z$1.ZodIntersection<T1["$internals"]["inputSchema"], T2["$internals"]["inputSchema"]>, T2["$internals"]["lastHandler"]>;

declare const instanceofZodTypeKind: <Z extends z.ZodFirstPartyTypeKind>(type: z.ZodTypeAny, zodTypeKind: Z) => type is InstanceType<(typeof z)[Z]>;
declare const unwrapZodType: (type: z.ZodTypeAny, unwrapPreprocess: boolean) => z.ZodTypeAny;
declare const instanceofZodTypeObject: (type: z.ZodTypeAny) => type is z.ZodObject<z.ZodRawShape, z.UnknownKeysParam, z.ZodTypeAny, {
    [x: string]: any;
}, {
    [x: string]: any;
}>;
declare const instanceofZodTypeArray: (type: z.ZodTypeAny) => type is z.ZodArray<z.ZodTypeAny, "many">;
declare const isKeyAnArrayInZodSchema: (key: string, schema: z.ZodTypeAny) => boolean;
declare const formDataToJson: (formData: FormData, inputSchema: z.ZodType) => Record<string, any>;
declare const addToNullishArray: <T>(array: Array<T> | undefined, value: T | undefined) => T[] | undefined;
declare const mergeArraysAndRemoveDuplicates: <T>(array1: Array<T> | undefined, array2: Array<T> | undefined) => T[] | undefined;

export { CompleteProcedure, DefaultOmitted, type InputTypeOptions, type PrettifyNested, type RetryConfig, type TAnyCompleteProcedure, type TAnyStateHandlerFunc, type TAnyZodSafeFunction, type TAnyZodSafeFunctionHandler, type TCompleteProcedureInternals, type TDataOrError, type TDataOrErrorOrNull, type THandlerFunc, type THandlerOpts, type TInternals, type TNoInputHandlerFunc, type TStateHandlerFunc, type TZSAError, type TZodSafeFunction, type TZodSafeFunctionDefaultOmitted, type TimeoutStatus, ZSAError, ZSAResponseMeta, ZodSafeFunction, addToNullishArray, chainServerActionProcedures, createServerAction, createServerActionProcedure, createZodSafeFunction, formDataToJson, type inferInputSchemaFromHandler, type inferServerActionError, type inferServerActionInput, type inferServerActionReturnData, type inferServerActionReturnType, type inferServerActionReturnTypeHot, instanceofZodTypeArray, instanceofZodTypeKind, instanceofZodTypeObject, isKeyAnArrayInZodSchema, mergeArraysAndRemoveDuplicates, unwrapZodType };
